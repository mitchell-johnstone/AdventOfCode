const std = @import("std");
const data = @embedFile("in_5.txt");

const Context = struct {
    map: std.AutoHashMap(usize, std.AutoHashMap(usize, void)),
    fn lessThan(self: Context, lhs: usize, rhs: usize) bool {
        return self.map.get(lhs).?.contains(rhs);
    }
};
// const node = struct {
//     value: i32,
//     children: []node,
//     filled: usize,
// };

pub fn main() !void {
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();
    const allocator = arena.allocator();
    std.debug.print("AOC 2024 sol 5\n-------------\n", .{});

    var lines = std.mem.splitScalar(u8, data, '\n');
    var from_to = std.AutoHashMap(usize, std.AutoHashMap(usize, void)).init(allocator);
    // will sort by adding the weight to the thousandth place.
    // the weight is generated by the order in the tree in the from_to map
    var rule_setup = true;
    var sum1: usize = 0;
    var sum2: usize = 0;
    while (lines.next()) |line| {
        if(line.len == 0) {
            rule_setup = false;
        } else if(rule_setup) {
            var pages = std.mem.splitScalar(u8, line, '|');
            const p: usize = try std.fmt.parseUnsigned(usize, pages.next().?, 10);
            const n: usize = try std.fmt.parseUnsigned(usize, pages.next().?, 10);

            if(!from_to.contains(p)){
                const set = std.AutoHashMap(usize, void).init(allocator);
                try from_to.put(p, set);
            }
            try from_to.getPtr(p).?.put(n, {});
        } else {
            var pages = std.mem.splitScalar(u8, line, ',');
            var arr = std.ArrayList(usize).init(allocator);
            defer arr.deinit();
            var valid = true;
            while(pages.next()) |page| {
                const n = try std.fmt.parseUnsigned(usize, page, 10);
                for (arr.items) |p| {
                    if(from_to.get(n)) |set| {
                        valid = valid and !set.contains(p);
                    }
                }
                try arr.append(n);
            }
            if(valid){
                sum1+=arr.items[arr.items.len / 2];
            } else {
                const context = Context{ .map = from_to };
                const dat = arr.items;
                std.mem.sort(usize, dat, context, Context.lessThan);
                sum2 += dat[ dat.len/2];
            }
        }
    }
    std.debug.print("{}\n", .{sum1});
    std.debug.print("{}\n", .{sum2});
}
